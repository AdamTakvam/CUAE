// dcmutil.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "NCMApi.h"

/////////////////////////////////////////////////////////////////////
#define DEVICE_FAMILY	"DM3"									
#define DEVICE_NAME		"HMP_Software #0 in slot 0/65535"	// default device name if there is only one
#define IGNORE_PCD		"1r1v0e0c0s0f_ver.pcd"				// the pcd file generated by default 1 port license

char gszPCDFile[512];

/////////////////////////////////////////////////////////////////////
int CallBackFunc(UINT uipercent, const char *message)
{
	printf("%d percent complete \n Status message: %s \n", uipercent, message);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////
int GetPCDFile(NCMFileInfo *fileList, int NumFiles, NCMDevInfo devInfo, int *index)
{
	int i = 0;

	// Try to match command line input for pcd file
	if (strlen(gszPCDFile) > 0)
	{
		for (i=0; i<NumFiles; i++)
		{
			if (!stricmp(fileList[i].fileName, gszPCDFile))
			{
				*index = i; 
				return *index;
			}
		}
	}

	// No good info from caller, list all PCD files on the system if there are more than 2
	for (i=0; i<NumFiles; i++)
	{
		printf ("Index %d, file name = %s \n", i, fileList[i].fileName);
	}

	printf("Please select file index: \n");
	int id = 0;
	scanf("%d", &id);
	*index = id;
	return *index;
}

/////////////////////////////////////////////////////////////////////
int DetectBoard()
{
	int iRet = 0;
	NCMRetCode ncmRc = NCM_SUCCESS;
	NCM_DETECTION_INFO detectionInfo;
	NCM_DETECTION_RESULT detectionResult;

	detectionInfo.structSize = sizeof(NCM_DETECTION_INFO);
	detectionInfo.callbackFcn = (NCM_CALLBACK_FCN*)CallBackFunc;
	detectionInfo.pcdFileSelectionFcn = (NCM_PCDFILE_SELECTION_FCN*)GetPCDFile;

	ncmRc = NCM_DetectBoardsEx(&detectionInfo, &detectionResult);
	if (ncmRc != NCM_SUCCESS)
	{
		NCMErrorMsg *pncmErrorMsg = NULL;
		ncmRc = NCM_GetErrorMsg(ncmRc, &pncmErrorMsg);
		if (ncmRc == NCM_SUCCESS)
		{
			printf ("NCM_DetectBoardsEx() returns error: %s\n", pncmErrorMsg->name);
		}
		else
		{
			printf("NCM_DetectBoardsEx() returns unknown error\n");
			NCM_Dealloc(pncmErrorMsg);
		}
	}
	else
	{
		printf("NCM_DetectBoardsEx() success, detected %d boards \n", detectionResult.totalDetectedBoards);
		iRet = detectionResult.totalDetectedBoards;
	}

	return iRet;
}

/////////////////////////////////////////////////////////////////////
void RestoreDefaults()
{
	NCMFamily ncmFamily = { DEVICE_FAMILY, NULL };		// device family
	NCMDevice ncmDevice = { DEVICE_NAME, NULL };		// device name

	NCMRetCode ncmRc = NCM_SUCCESS;
	NCM_DETECTION_INFO detectionInfo;
	detectionInfo.structSize = sizeof(NCM_DETECTION_INFO);
	detectionInfo.callbackFcn = (NCM_CALLBACK_FCN*)CallBackFunc;					// progress callback function
	detectionInfo.pcdFileSelectionFcn = (NCM_PCDFILE_SELECTION_FCN*)GetPCDFile;	// PCD file selection callback function

	NCMDevice * pncmNewDevice = NULL;

	ncmRc = NCM_ReconfigBoard(&ncmFamily, &ncmDevice, &detectionInfo, &pncmNewDevice);
	if (ncmRc != NCM_SUCCESS)
	{
		NCMErrorMsg *pncmErrorMsg = NULL;
		ncmRc = NCM_GetErrorMsg(ncmRc, &pncmErrorMsg);
		if (ncmRc == NCM_SUCCESS)
		{
			printf ("NCM_ReconfigureBoard() returns error: %s\n", pncmErrorMsg->name);
		}
		else
		{
			printf("NCM_ReconfigureBoard() returns unknown error\n");
			NCM_Dealloc(pncmErrorMsg);
		}
	}
	else
	{
		printf ("NCM_ReconfigureBoard() returns success\n");
	}
	NCM_Dealloc(pncmNewDevice);
}

/////////////////////////////////////////////////////////////////////
int _tmain(int argc, _TCHAR* argv[])
{
	memset(&gszPCDFile, 0, sizeof(gszPCDFile));

	if (argc > 1)
		lstrcpy(gszPCDFile, argv[1]);

	if (DetectBoard() > 0)
		RestoreDefaults();

	return 0;
}
