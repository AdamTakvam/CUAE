using System;
using System.Diagnostics;

namespace Metreos.SccpStack
{
	/// <summary>
	/// Represents a thread-safe factory of unique integer tags, or
	/// identifiers.
	/// </summary>
	public class TagFactory
	{
		/// <summary>
		/// Constructs a TagFactory using the default tag range.
		/// </summary>
		public TagFactory() : this(Const.MinTag, Const.MaxTag) { }

		/// <summary>
		/// Constructs a TagFactory according to the specified range of tag
		/// values but doesn't care whether the generated tags are even or odd.
		/// </summary>
		/// <param name="minTag">Minimum tag value.</param>
		/// <param name="maxTag">Maximum tag value. Actually, max is one less
		/// than this.</param>
		public TagFactory(int minTag, int maxTag) :
			this(minTag, maxTag, Parity.None) { }

		/// <summary>
		/// Constructs a TagFactory according to the specified parity and range
		/// of tag values.
		/// </summary>
		/// <remarks>
		/// The starting value is random but within the range. Similar to the
		/// Random.Next() method, the resulting tags are greater than or equal
		/// to minTag and less than maxTag, so TagFactory(1, 1000) would cause
		/// TagFactory.Next to return from 1 to 999.
		/// </remarks>
		/// <param name="minTag">Minimum tag value.</param>
		/// <param name="maxTag">Maximum tag value. Actually, max is one less
		/// than this.</param>
		/// <param name="parity">Whether the tags are even, odd, or it doesn't
		/// matter.</param>
		public TagFactory(int minTag, int maxTag, Parity parity)
		{
			// Adjust minimum according to the specified parity.
			this.minTag = Parityize(minTag, parity);
			this.maxTag = maxTag;

			// Let's start at a different tag each time just to exercise code
			// and make sure nobody makes any bad assumptions about tags.
			tag = (new Random()).Next(this.minTag, this.maxTag);

			// Adjust starting tag to specified parity because Random() method
			// doesn't know to abide by our parity setting.
			tag = Parityize(tag, parity);

			// Create object just so we have a reference on which to lock.
			syncRoot = new object();

			// Get next tag in case starting, parityized tag just happened to
			// be equal to maximum.
			int dummy = Next;

			// How much to increment the next tag by, according to parity.
			increment = parity == Parity.None ? 1 : 2;
		}

		/// <summary>
		/// Whether tags generated by the tag factory are even, odd, or it
		/// doesn't matter (in which case, they increase monotonically).
		/// </summary>
		public enum Parity
		{
			Even,
			Odd,
			None
		}

		/// <summary>
		/// Lock on this otherwise useless object instead of "this."
		/// </summary>
		/// <remarks>Adam said that it's faster to lock on an inner object
		/// rather than "this" or an outer object.</remarks>
		private readonly object syncRoot;

		/// <summary>
		/// Amount to increment tag each time a new one is requested.
		/// </summary>
		private readonly int increment;

		/// <summary>
		/// Read-only property that returns a unique tag (at least until the
		/// value wraps around to the starting tag).
		/// </summary>
		public int Next
		{
			get
			{
				int returnTag;

				lock (syncRoot)
				{
					if (tag >= maxTag)
					{
						tag = minTag;
					}

					returnTag = tag;
					tag += increment;
				}

				return returnTag;
			}
		}

		// Default tag range.
		private abstract class Const
		{
			public const int MinTag = 1;	// (Negative tags are just too weird.)
			public const int MaxTag = int.MaxValue;
		}

		/// <summary>
		/// This is the next tag value to be returned by the Next property.
		/// </summary>
		private volatile int tag;

		/// <summary>
		/// Minimum tag value.
		/// </summary>
		private readonly int minTag;

		/// <summary>
		/// Maximum tag value. Actually, max is one less than this.
		/// </summary>
		private readonly int maxTag;

		/// <summary>
		/// Adjust parameter according to the current parity setting.
		/// </summary>
		/// <param name="n">Parameter to "parityize."</param>
		/// <param name="parity">Whether to adjust the value to be even, odd,
		/// or don't adjust at all.</param>
		/// <returns>Parityized value.</returns>
		private int Parityize(int n, Parity parity)
		{
			switch (parity)
			{
				case Parity.Even:
					// If already even then leave alone; if odd, bump
					// up to next (even) integer.
					++n;
					n >>= 1;
					n <<= 1;
					break;

				case Parity.Odd:
					// If already odd then leave alone; if even, bump
					// up to next (odd) integer.
					n |= 1;
					break;

				case Parity.None:
					// (Do nothing.)
					break;

				default:
					Debug.Fail("SccpProxyProvider: invalid parity");
					break;
			}

			return n;
		}
	}
}
