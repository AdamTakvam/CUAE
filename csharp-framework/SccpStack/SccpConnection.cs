using System;
using System.Net;
using System.Threading;
using System.IO;
using System.Net.Sockets;
using System.Collections;
using System.Diagnostics;

using Metreos.Utilities;
using Metreos.Utilities.Selectors;
using Metreos.LoggingFramework;

namespace Metreos.SccpStack
{
	/// <summary>
	/// Type of delegate for handling establishment of TCP connection with
	/// CallManager.
	/// </summary>
	internal delegate void ConnectedHandler(SccpConnection connection);

	/// <summary>
	/// Type of delegate for handling receipt of low-level, SCCP messages.
	/// </summary>
	internal delegate void SccpMessageHandler(SccpConnection connection,
		SccpMessage message);

	/// <summary>
	/// Type of delegate for handling errors on the connection.
	/// </summary>
	internal delegate void ErrorHandler(SccpConnection connection,
		Exception exception);

	/// <summary>
	/// Represents a low-level, SCCP-message-based connection.
	/// </summary>
	/// <remarks>
	/// This can be used for communicating with a CallManager or a client.
	/// </remarks>
	public class SccpConnection
	{
		/// <summary>
		/// Constructs an SccpConnection.
		/// </summary>
		/// <remarks>Gets ready but doesn't actually establish a
		/// connection.</remarks>
		/// <param name="log">Object through which log entries are generated.</param>
		/// <param name="address">IPEndPoint address to which we connect.</param>
		/// <param name="selector">Selector that performs socket I/O for
		/// all connections.</param>
		/// <param name="threadPool">Thread pool to offload processing of
		/// selected actions from selector callback.</param>
		public SccpConnection(LogWriter log, IPEndPoint address,
			SelectorBase selector, Metreos.Utilities.ThreadPool threadPool)
		{
			this.log = log;
			this.address = address;
			this.selector = selector;
			this.threadPool = threadPool;

			startConnectNs = HPTimer.Now();

			readBuffer = new byte[Const.ReadBufferLength];

			messageFactory = new SccpMessageFactory();

			deblocker = new Deblocker(new ProcessMessageDelegate(ProcessMessage), log);

			shutdownRequested = false;

			// When processQueueDelegate invoked with nothing in
			// queue, that means that it is being invoked due to
			// being selected for Connected.
			queue = Queue.Synchronized(new Queue());
			processQueueDelegate = new WorkRequestDelegate(ProcessQueue);
			processConnectedDelegate = new WorkRequestDelegate(ProcessConnected);

			processingQueue = false;
			processingQueueLock = new object();

			LogVerbose("Con: {0}: created", this);
		}

		/// <summary>
		/// Thread pool to offload processing of selected actions from
		/// selector callback.
		/// </summary>
		private readonly Metreos.Utilities.ThreadPool threadPool;

		/// <summary>
		/// Queue that contains datagrams received over the TCP connection to
		/// the CallManager.
		/// </summary>
		private readonly Queue queue;

		/// <summary>
		/// Delegate for processing an incoming-data queue.
		/// </summary>
		private readonly Metreos.Utilities.WorkRequestDelegate processQueueDelegate;

		/// <summary>
		/// Delegate for processing the fact that a socket has connected.
		/// </summary>
		private readonly Metreos.Utilities.WorkRequestDelegate processConnectedDelegate;

		/// <summary>
		/// Inidicates whether a thread has been dispatched to process entries
		/// in the incoming-data queue.
		/// </summary>
		private volatile bool processingQueue;

		/// <summary>
		/// Used to synchronize the thread-safe accessing of processingQueue.
		/// </summary>
		private object processingQueueLock;

		/// <summary>
		/// Constants referenced within this class.
		/// </summary>
		private abstract class Const
		{
			/// <summary>
			///  Arbitrary read-buffer length. Make it as big as the typical
			///  packet. We accumulate the data from each read into a
			///  variable-length buffer, so we can actually handle packets
			///  larger than this.
			/// </summary>
			public const int ReadBufferLength = 1024;
		}

		#region Configuration parameters
		/// <summary>
		/// Whether to log Verbose diagnostics.
		/// </summary>
		private static bool isLogVerbose = false;

		/// <summary>
		/// Whether to log Verbose diagnostics.
		/// </summary>
		internal static bool IsLogVerbose { set { isLogVerbose = value; } }
		#endregion

		#region Events for SCCP messages from connection to stack

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// ActivateCallPlane event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler ActivateCallPlaneEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// Alarm event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler AlarmEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// BackspaceReq event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler BackspaceReqEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// ButtonTemplate event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler ButtonTemplateEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// ButtonTemplateReq event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler ButtonTemplateReqEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// CallInfo event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler CallInfoEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// CallSelectStat event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler CallSelectStatEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// CallState event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler CallStateEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// CapabilitiesReq event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler CapabilitiesReqEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// CapabilitiesRes event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler CapabilitiesResEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// ClearDisplay event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler ClearDisplayEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// ClearNotify event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler ClearNotifyEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// ClearPriorityNotify event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler ClearPriorityNotifyEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// ClearPromptStatus event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler ClearPromptStatusEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// CloseReceiveChannel event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler CloseReceiveChannelEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// ConfigStat event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler ConfigStatEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// ConnectionStatisticsReq event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler ConnectionStatisticsReqEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// ConnectionStatisticsRes event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler ConnectionStatisticsResEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// DeactivateCallPlane event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler DeactivateCallPlaneEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// DefineTimeDate event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler DefineTimeDateEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// DeviceToUserData event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler DeviceToUserDataEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// DeviceToUserDataRes event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler DeviceToUserDataResEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// DialedNumber event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler DialedNumberEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// DisplayNotify event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler DisplayNotifyEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// DisplayPriorityNotify event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler DisplayPriorityNotifyEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// DisplayPromptStatus event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler DisplayPromptStatusEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// DisplayText event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler DisplayTextEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// FeatureStat event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler FeatureStatEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// FeatureStatReq event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler FeatureStatReqEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// ForwardStat event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler ForwardStatEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// HeadsetStatus event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler HeadsetStatusEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// IpPort event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler IpPortEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// Keepalive event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler KeepaliveEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// KeepaliveAck event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler KeepaliveAckEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// KeypadButton event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler KeypadButtonEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// LineStat event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler LineStatEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// LineStatReq event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler LineStatReqEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// OffhookSccp event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler OffhookSccpEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// Onhook event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler OnhookEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// OpenReceiveChannel event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler OpenReceiveChannelEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// OpenReceiveChannelAck event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler OpenReceiveChannelAckEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// Register event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler RegisterEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// RegisterAvailableLines event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler RegisterAvailableLinesEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// RegisterAck event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler RegisterAckEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// RegisterReject event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler RegisterRejectEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// RegisterTokenAck event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler RegisterTokenAckEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// RegisterTokenReject event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler RegisterTokenRejectEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// RegisterTokenReq event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler RegisterTokenReqEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// Reset event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler ResetEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// SelectSoftkeys event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler SelectSoftkeysEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// ServerRes event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler ServerResEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// ServiceUrlStat event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler ServiceUrlStatEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// ServiceUrlStatReq event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler ServiceUrlStatReqEvent = null;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// SetLamp event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler SetLampEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// SetRinger event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler SetRingerEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// SetSpeakerMode event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler SetSpeakerModeEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// SetMicroMode event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler SetMicroModeEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// SoftkeyEvent event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler SoftkeyEventEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// SoftkeySetReq event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler SoftkeySetReqEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// SoftkeySetRes event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler SoftkeySetResEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// SoftkeyTemplateReq event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler SoftkeyTemplateReqEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// SoftkeyTemplateRes event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler SoftkeyTemplateResEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// SpeeddialStat event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler SpeeddialStatEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// SpeeddialStatReq event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler SpeeddialStatReqEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// StartMediaFailureDetection event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler StartMediaFailureDetectionEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// StartMediaTransmission event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler StartMediaTransmissionEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// StartMulticastMediaReception event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler StartMulticastMediaReceptionEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// StartMulticastMediaTransmission event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler StartMulticastMediaTransmissionEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// StartSessionTransmission event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler StartSessionTransmissionEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// StartTone event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler StartToneEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// StopMediaTransmission event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler StopMediaTransmissionEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// StopMulticastMediaReception event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler StopMulticastMediaReceptionEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// StopMulticastMediaTransmission event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler StopMulticastMediaTransmissionEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// StopSessionTransmission event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler StopSessionTransmissionEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// StopTone event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler StopToneEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// TimeDateReq event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler TimeDateReqEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// Unregister event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler UnregisterEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// UnregisterAck event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler UnregisterAckEvent;

		/// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// UserToDeviceData event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler UserToDeviceDataEvent;

        /// <summary>
        /// Consumer subscribes to this event to receive the low-level,
        /// UserToDeviceDataVersion1 event generated by the SccpConnection that
        /// corresponds to the received SCCP message of the same name.
        /// </summary>
        internal SccpMessageHandler UserToDeviceDataVersion1Event;
        
        /// <summary>
		/// Consumer subscribes to this event to receive the low-level,
		/// Version_ event generated by the SccpConnection that
		/// corresponds to the received SCCP message of the same name.
		/// </summary>
		internal SccpMessageHandler Version_Event;

		#endregion

		#region static members
		/// <summary>
		/// Number of seconds for socket to linger after Close() is called
		/// on it.
		/// </summary>
		private static int lingerSec = 2;

		/// <summary>
		/// Number of seconds for socket to linger after Close() is called
		/// on it.
		/// </summary>
		public static int LingerSec { set { lingerSec = value; } }
		#endregion

		/// <summary>
		/// Property whose value is whether the connection is established to a
		/// remote host.
		/// </summary>
		public bool Connected { get { return key != null && key.IsOpen(); } }

		/// <summary>
		/// Property whose value is the IPEndPoint address of the local end of
		/// this connection or null if Socket is null or not connected.
		/// </summary>
		public IPEndPoint LocalEndPoint
		{
			get
			{
				IPEndPoint endpoint;
				try
				{
					endpoint = Connected ? key.Socket.LocalEndPoint as IPEndPoint : null;
				}
				// In case LocalEndPoint triggers exception; can't just check
				// socket.Connected.
				catch
				{
					endpoint = null;
				}

				return endpoint;
			}
		}

		/// <summary>
		/// Property whose value is the IPEndPoint address of the remote end of
		/// this connection or null if Socket is null or not connected.
		/// </summary>
		public IPEndPoint RemoteEndPoint
		{
			get
			{
				IPEndPoint endpoint;
				try
				{
					endpoint = Connected ? key.Socket.RemoteEndPoint as IPEndPoint : null;
				}
				catch
				{
					// SocketException.ErrorCode == 10057 when the socket is
					// truly not connected; socket.Connected doesn't always
					// return accurate information.
					endpoint = null;
				}

				return endpoint;
			}
		}

		/// <summary>
		/// Set to true when the connection is requested to terminate.
		/// </summary>
		private volatile bool shutdownRequested;

		/// <summary>
		/// Object through which log entries are generated.
		/// </summary>
		/// <remarks>Access to this object does not need to be controlled
		/// because it is not modified after construction.</remarks>
		private readonly LogWriter log;

		/// <summary>
		/// Isolates discrete SCCP messages within the incoming TCP byte
		/// stream.
		/// </summary>
		private readonly Deblocker deblocker;

		/// <summary>
		/// Factory that returns an internal representation of the raw SCCP
		/// message contained in a deblocked SCCP message.
		/// </summary>
		private readonly SccpMessageFactory messageFactory;

		/// <summary>
		/// IPEndPoint address of remote entity to which we connect.
		/// </summary>
		private readonly IPEndPoint address;

		/// <summary>
		/// Delegate that handles establishment of TCP connection with
		/// CallManager.
		/// </summary>
		internal ConnectedHandler ConnectedEvent = null;

		/// <summary>
		/// Delegate that handles errors on the connection.
		/// </summary>
		internal ErrorHandler ErrorEvent = null;

		/// <summary>
		/// Key that encapsulates the socket for use by the Selector.
		/// </summary>
		private volatile Utilities.Selectors.SelectionKey key;

		/// <summary>
		/// Wrapper for the thread doing Socket.Select().
		/// </summary>
		/// <remarks>
		/// All Socket operations are performed through this object.
		/// </remarks>
		private readonly SelectorBase selector;

		/// <summary>
		/// Raw read buffer. The result of each read is read directly into here.
		/// We then accumulate that into the variable-length packet buffer.
		/// </summary>
		private readonly byte[] readBuffer;

		/// <summary>
		/// Time that asynchronous Connect was initiated.
		/// </summary>
		private long startConnectNs;

		/// <summary>
		/// Establishes a TCP connection.
		/// </summary>
		internal bool Start()
		{
			Socket socket = new Socket(AddressFamily.InterNetwork,
				SocketType.Stream, ProtocolType.Tcp);
			socket.Blocking = false;		// Don't block since using Socket.Select
			socket.SetSocketOption(SocketOptionLevel.Socket,
				SocketOptionName.Linger,	// Ensure all data is written after Close
				new LingerOption(true, lingerSec));

			startConnectNs = HPTimer.Now();
			try
			{
				// Initiate asynchronous Connect attempt through Socket.Select().
				// (Apparently we don't need to call EndConnect(). The selector
				// fires when the socket is connected.)
				socket.BeginConnect(address, null, null);
			}
			catch (SocketException e)
			{
				// Should normally get would-block exception.
				if (e.ErrorCode != 10035)
				{
					try
					{
						int handleCount = Process.GetCurrentProcess().HandleCount;

						log.Write(TraceLevel.Error,
							"Con: {0}: connect failed after {1}ms (handles: {2}); {3}, {4}",
							this, (HPTimer.Now() - startConnectNs) / 1000 / 1000,
							handleCount, e.ErrorCode, e.Message);
					}
					catch
					{
						log.Write(TraceLevel.Error,
							"Con: {0}: connect failed after {1}ms (could not get handle count); {2}, {3}",
							this, (HPTimer.Now() - startConnectNs) / 1000 / 1000,
							e.ErrorCode, e.Message);
					}

					socket.Close();
					socket = null;
				}
			}
			catch (Exception e)
			{
				try
				{
					int handleCount = Process.GetCurrentProcess().HandleCount;

					log.Write(TraceLevel.Error,
						"Con: {0}: connect failed after {1}ms (handles: {2}); {3}",
						this, (HPTimer.Now() - startConnectNs) / 1000 / 1000,
						handleCount, e.Message);
				}
				catch
				{
					log.Write(TraceLevel.Error,
						"Con: {0}: connect failed after {1}ms (could not get handle count); {2}",
						this, (HPTimer.Now() - startConnectNs) / 1000 / 1000, e.Message);
				}

				socket.Close();
				socket = null;
			}

			if (socket != null)
			{
				LogVerbose(
					"Con: {0}: asynchronous connect successfully initiated after {1}ms",
					this, (HPTimer.Now() - startConnectNs) / 1000 / 1000);

				long startRegisterNs = HPTimer.Now();
				key = selector.Register(socket, this);
				long withinRegisterMs = (HPTimer.Now() - startRegisterNs) / 1000 / 1000;
				if (withinRegisterMs > 1000)
				{
					log.Write(TraceLevel.Warning,
						"Con: {0}: Register() took long time ({1}ms)",
						this, withinRegisterMs);
				}

				if (key == null)
				{
					log.Write(TraceLevel.Error,
						"Con: {0}: selector registration failed", this);

					socket.Close();
					socket = null;
				}
				else
				{
					key.WantsConnect = true;
				}
			}

			return socket != null;
		}

		/// <summary>
		/// Flags that we are shutting down this connection.
		/// </summary>
		/// <remarks>
		/// Don't receive any more messages, don't queue up any more messages
		/// to be sent, and when all queued up messages to be sent have been
		/// sent, close the socket. If there aren't any queued up right now,
		/// close the sockets now.
		/// </remarks>
		internal void Shutdown()
		{
			LogVerbose("Con: {0}: shutting down", this);

			shutdownRequested = true;

			CloseKey();
		}

		/// <summary>
		/// Closes the selector key and underlying socket.
		/// </summary>
		private void CloseKey()
		{
			if (key != null)
			{
				if (key.IsOpen())
				{
					key.Close();
				}
			}
		}

		/// <summary>
		/// Processes the selection of read, write, and error actions.
		/// </summary>
		/// <param name="key">Key that identifies the socket selected for action.</param>
		internal static void Selected(Utilities.Selectors.SelectionKey key)
		{
			SccpConnection connection = key.Data as SccpConnection;

			if (key.IsSelectedForAccept)
			{
				Debug.Fail("SccpStack: unexpected accept selection");
				key.WantsAccept = false;
			}

			if (key.IsSelectedForRead && !connection.ReceiveMessageAction(key.Socket))
			{
				key.WantsRead = false;
			}

			if (key.IsSelectedForWrite)
			{
				Debug.Fail("SccpStack: unexpected write selection");
				key.WantsWrite = false;
			}

			if (key.IsSelectedForConnect)
			{
				connection.LogVerbose("Con: {0}: connected after {1}ms",
					connection,
					(HPTimer.Now() - connection.startConnectNs) / 1000 / 1000);

				// (We should supposedly call EndConnect() here but it
				// apparently isn't needed.)

				connection.threadPool.PostRequest(connection.processConnectedDelegate);
				key.WantsConnect = false;
			}

			if (key.IsSelectedForError)
			{
				connection.ProcessErrorEvent(new SocketException());
			}
		}

		/// <summary>
		/// Processes selected error event.
		/// </summary>
		/// <param name="exception">Exception to process.</param>
		internal void ProcessErrorEvent(Exception exception)
		{
			// Close now or we'll continue to get selected for error.
			key.Close();

			Enqueue(exception);
		}

		/// <summary>
		/// Logs exception from within Selector.
		/// </summary>
		/// <param name="key">Relevant key.</param>
		/// <param name="e">Exception information, e.g., text describing the exception.</param>
		public static void SelectedException(Utilities.Selectors.SelectionKey key, Exception e)
		{
			SccpConnection connection = key.Data as SccpConnection;

			connection.log.Write(TraceLevel.Error, "Con: selected exception: {0}", e);
		}

		/// <summary>
		/// Sends SCCP message.
		/// </summary>
		/// <param name="message">SccpMessage to send.</param>
		/// <returns>Whether the message was sent (whether the connection is
		/// still established).</returns>
		internal bool Send(SccpMessage message)
		{
			bool sent = false;

			if (message == null)
			{
				log.Write(TraceLevel.Error,
					"Con: {0}: attempt to send missing message; not sent",
					this);
			}
			else
			{
				if (!Connected)
				{
					log.Write(TraceLevel.Error,
						"Con: {0}: attempt to send while not conected; {1} not sent",
						this, message);
				}
				else
				{
					byte[] rawMessage = message.Raw;
					if (rawMessage.Length == 0)
					{
						log.Write(TraceLevel.Error,
							"Con: {0}: attempt to send empty message; ignored",
							this);
					}
					else
					{
						LogVerbose("Con: {0}: sending {1}", this, message);

						Exception exception = null;
						int bytesSent = 0;
						try
						{
							bytesSent = key.Socket.Send(rawMessage);
						}
						catch (Exception e)		// We don't care why Send failed.
						{
							exception = e;
							bytesSent = 0;
						}

						if (bytesSent == 0)
						{
							Debug.Assert(exception != null,
								"SccpStack: no bytes sent yet no exception");

							// (Doesn't really need to be Enqueued, but it
							// doesn't hurt, and that's how all the other
							// socket Exceptions are processed.)
							Enqueue(exception);
						}
						else
						{
							Debug.Assert(exception == null,
								"SccpStack: exception yet bytes sent");

							sent = true;
						}
					}
				}
			}

			return sent;
		}

		/// <summary>
		/// Handles receipt of low-level, SCCP messages.
		/// </summary>
		/// <remarks>
		/// Called through delegate from selector whenever there is data to
		/// read on this connection's socket.
		/// </remarks>
		/// <param name="socket">Socket from which to read.</param>
		/// <returns>Whether to check for more data to read.</returns>
		private bool ReceiveMessageAction(Socket socket)
		{
			bool again = true;

			// Receive a TCP datagram (one has to be ready to read or else the
			// Selector wouldn't have invoked us) and toss it to the Deblocker
			// to look for any whole SCCP messages in its accumulated byte
			// stream. Invoke the ErrorEvent if an error occurs on the Socket.

			Exception exception = null;
			int bytesRead = 0;
			try
			{
				bytesRead = socket.Receive(readBuffer);
			}
			catch (SocketException e)			// Miscellaneous socket error.
			{
				// Generate log entry if unexpected error.
				if (e.ErrorCode != 10054 &&		// Remote host forcibly closed connection
					e.ErrorCode != 10053)		// We aborted connection elsewhere while attempting to read
				{
					log.Write(TraceLevel.Error,
						"Con: {0}: socket exception {1} during receive: {2}",
						this, e.ErrorCode, e.Message);
				}
				exception = e;
				bytesRead = 0;
			}
			catch (ObjectDisposedException e)	// Socket is closed.
			{
				if (shutdownRequested)
				{
					// Stack must have closed socket right after Socket.Select()
					// found data for us to read but before the thread pool could
					// dispatch a thread to read the data via this method.
				}
				else
				{
					// Socket must have closed unexpectedly.
					log.Write(TraceLevel.Error,
						"Con: {0}: object-disposed exception during receive: {1}",
						this, e);
					exception = e;
				}
				bytesRead = 0;
			}
			catch (NullReferenceException e)	// Socket is null.
			{
				log.Write(TraceLevel.Error,
					"Con: {0}: null-socket exception during receive: {1}",
					this, e);
				exception = e;
				bytesRead = 0;
			}
			catch (Exception e)					// In case some other exception
			{
				log.Write(TraceLevel.Error,
					"Con: {0}: exception during receive: {1}", this, e);
				exception = e;
				bytesRead = 0;
			}

			if (bytesRead > 0)
			{
				byte[] datagram = new byte[bytesRead];
				Array.Copy(readBuffer, 0, datagram, 0, bytesRead);
				Enqueue(datagram);
			}
			else
			{
				ProcessErrorEvent(exception);

				again = false;
			}

			return again;
		}

		/// <summary>
		/// Processes the fact that we connected a socket to a CallManager.
		/// </summary>
		/// <param name="notUsed">Not used. Needed data accessed as this
		/// object's members.</param>
		private void ProcessConnected(object notUsed)
		{
			Debug.Assert(notUsed == null,
				"SccpStack: object unexpectedly passed into delegate");
			Debug.Assert(!processingQueue,
				"SccpStack: processingQueue set to true upon processing the connect (queue not used yet)");
			Debug.Assert(!key.WantsRead, "SccpStack: wants reads before we said to");

			// Now that we know we are connected, we can allow the selector
			// to select for reads and then process the fact that we have
			// connected.
			key.WantsRead = true;
			LogVerbose("Con: {0}: proceeding with reads", this);

			if (ConnectedEvent != null)
			{
				ConnectedEvent(this);
			}
		}

		/// <summary>
		/// Processes an incoming-data queue containing datagrams from the
		/// CallManager.
		/// </summary>
		/// <remarks>
		/// Invoked if this connection's socket was
		/// 1. selected for read (at least one datagram in the incoming-data queue), and
		/// 2. selected for error (an Exception or null is on the queue).
		/// </remarks>
		/// <param name="notUsed">Not used. Needed data accessed as this
		/// object's members.</param>
		private void ProcessQueue(object notUsed)
		{
			Debug.Assert(notUsed == null,
				"SccpStack: object unexpectedly passed into delegate");
			Debug.Assert(processingQueue,
				"SccpStack: processingQueue set to false upon starting to process queue");
			// (We can handle an empty queue, but it shouldn't happen--a waste of a thread.)
			Debug.Assert(queue.Count > 0, "SccpStack: empty queue--no entries to process");

			do
			{
				// Process datagrams until queue empty. (Since we only lock while
				// Dequeuing, datagrams can be added while we process previously
				// received ones.)
				byte[] datagram;
				Exception exception;
				while (Dequeue(out datagram, out exception))
				{
					if (datagram != null)
					{
						Debug.Assert(exception == null, "SccpStack: unexpected exception");

						deblocker.ProcessReadData(datagram, datagram.Length);
					}
					else
					{
						// Only process error if we are not in the process of shutting
						// down.
						if (ErrorEvent != null && !shutdownRequested)
						{
							ErrorEvent(this, exception);
						}
					}
				}
			}
			while (LateArrivals());
		}

		/// <summary>
		/// Determines whether entries were added to the queue since we last
		/// checked. If they were not, processingQueue is set to false,
		/// indicating that this thread invocation is done processing the
		/// queue and that a new thread must be invoked to process new entries
		/// in the queue.
		/// </summary>
		/// <returns>Whether there are late arrivals to the queue.</returns>
		private bool LateArrivals()
		{
			bool lateArrivals;

			lock (processingQueueLock)
			{
				Debug.Assert(processingQueue,
					"SccpStack: !processingQueue while processing queue");

				lateArrivals = queue.Count > 0;
				if (!lateArrivals)
				{
					processingQueue = false;
				}
			}

			return lateArrivals;
		}

		/// <summary>
		/// Gets next entry from the incoming-data queue.
		/// </summary>
		/// <param name="datagram">Next datagram removed from the queue if byte
		/// array.</param>
		/// <param name="exception">Next Exception or null removed from the
		/// queue if Exception or null.</param>
		/// <returns>Whether an entry was gotten from queue.</returns>
		private bool Dequeue(out byte[] datagram, out Exception exception)
		{
			bool gotEntry = false;

			datagram = null;
			exception = null;

			// In case invoked by multiple threads, only process one
			// datagram at a time. Queue is already Synchronized but the two
			// actions, determining Count and then Dequeuing, need to be
			// synchronized.
			for (int i = 1; !Monitor.TryEnter(queue.SyncRoot,
				SccpStack.LockPollMs); ++i)
			{
				log.Write(TraceLevel.Warning,
					"Con: waited {0} times for lock within Dequeue()", i);
			}
			long lockAcquiredNs = HPTimer.Now();
			try
			{
				if (queue.Count > 0)
				{
					object entry = queue.Dequeue();

					if (entry == null)
					{
						gotEntry = true;
					}
					else if (entry is Exception)
					{
						exception = (Exception)entry;
						gotEntry = true;
					}
					else if (entry is byte[])
					{
						datagram = (byte[])entry;
						gotEntry = true;
					}
				}
			}
			finally
			{
				Monitor.Exit(queue.SyncRoot);
			}
			long lockHeldMs = (HPTimer.Now() - lockAcquiredNs) / 1000 / 1000;
			if (lockHeldMs > SccpStack.LockPollMs)
			{
				log.Write(TraceLevel.Warning,
					"Con: lock held long time ({0}ms) within Dequeue()",
					lockHeldMs);
			}

			return gotEntry;
		}

		/// <summary>
		/// Puts entry into the incoming-data queue.
		/// </summary>
		/// <param name="datagram">Entry to enqueue.</param>
		private void Enqueue(object entry)
		{
			// If Exception or null (a kind of "exception"), expedite its
			// processing by clearing out the queue first. Any entries already
			// in the queue don't matter of there is an exception.
			if (entry == null || entry is Exception)
			{
				// In case invoked by multiple threads, only process one
				// datagram at a time. Queue is already Synchronized but the two
				// actions, determining Count and then Dequeuing, need to be
				// synchronized.
				for (int i = 1; !Monitor.TryEnter(queue.SyncRoot,
					SccpStack.LockPollMs); ++i)
				{
					log.Write(TraceLevel.Warning,
						"Con: waited {0} times for lock within Enqueue()", i);
				}
				long lockAcquiredNs = HPTimer.Now();
				try
				{
					queue.Clear();
					queue.Enqueue(entry);
				}
				finally
				{
					Monitor.Exit(queue.SyncRoot);
				}
				long lockHeldMs = (HPTimer.Now() - lockAcquiredNs) / 1000 / 1000;
				if (lockHeldMs > SccpStack.LockPollMs)
				{
					log.Write(TraceLevel.Warning,
						"Con: lock held long time ({0}ms) within ClearQueue()",
						lockHeldMs);
				}
			}
			else
			{
				Debug.Assert(entry is byte[], "SccpStack: entry is not byte array");

				queue.Enqueue(entry);
			}

			// Assure that this new entry in the queue will be processed by the
			// delegate.
			lock (processingQueueLock)
			{
				// If we're not already processing the queue and the entry we
				// just added hasn't already been processed by the delegate
				// (could happen), start a new thread to process the queue.
				if (!processingQueue && queue.Count > 0)
				{
					processingQueue = true;
					threadPool.PostRequest(processQueueDelegate);
				}
			}
		}

		/// <summary>
		/// Processes a whole SCCP message that the Deblocker has isolated
		/// within the incoming byte stream on the TCP connection.
		/// </summary>
		/// <param name="buffer">Byte array that contains the raw SCCP
		/// message.</param>
		private void ProcessMessage(byte[] buffer)
		{
			// Have the message factory decode the SCCP message and return
			// an internal representation of it.
			SccpMessage message = messageFactory.GetMessage(buffer);
			if (message == null)
			{
				log.Write(TraceLevel.Error, "Con: {0}: message not recognized: {1}", this, buffer);
			}
			else
			{
				// Based on the MessageType, invoke the corresponding callback
				// if the consumer has subscribed to this message.
				switch (message.MessageType)
				{
					case SccpMessage.Type.ActivateCallPlane:
						if (ActivateCallPlaneEvent != null)
						{
							ActivateCallPlaneEvent(this, message);
						}
						break;

					case SccpMessage.Type.Alarm:
						if (AlarmEvent != null)
						{
							AlarmEvent(this, message);
						}
						break;

					case SccpMessage.Type.BackspaceReq:
						if (BackspaceReqEvent != null)
						{
							BackspaceReqEvent(this, message);
						}
						break;

					case SccpMessage.Type.ButtonTemplate:
						if (ButtonTemplateEvent != null)
						{
							ButtonTemplateEvent(this, message);
						}
						break;

					case SccpMessage.Type.ButtonTemplateReq:
						if (ButtonTemplateReqEvent != null)
						{
							ButtonTemplateReqEvent(this, message);
						}
						break;

					case SccpMessage.Type.CallInfo:
						if (CallInfoEvent != null)
						{
							CallInfoEvent(this, message);
						}
						break;

					case SccpMessage.Type.CallSelectStat:
						if (CallSelectStatEvent != null)
						{
							CallSelectStatEvent(this, message);
						}
						break;

					case SccpMessage.Type.CallState:
						if (CallStateEvent != null)
						{
							CallStateEvent(this, message);
						}
						break;

					case SccpMessage.Type.CapabilitiesReq:
						if (CapabilitiesReqEvent != null)
						{
							CapabilitiesReqEvent(this, message);
						}
						break;

					case SccpMessage.Type.CapabilitiesRes:
						if (CapabilitiesResEvent != null)
						{
							CapabilitiesResEvent(this, message);
						}
						break;

					case SccpMessage.Type.ClearDisplay:
						if (ClearDisplayEvent != null)
						{
							ClearDisplayEvent(this, message);
						}
						break;

					case SccpMessage.Type.ClearNotify:
						if (ClearNotifyEvent != null)
						{
							ClearNotifyEvent(this, message);
						}
						break;

					case SccpMessage.Type.ClearPriorityNotify:
						if (ClearPriorityNotifyEvent != null)
						{
							ClearPriorityNotifyEvent(this, message);
						}
						break;

					case SccpMessage.Type.ClearPromptStatus:
						if (ClearPromptStatusEvent != null)
						{
							ClearPromptStatusEvent(this, message);
						}
						break;

					case SccpMessage.Type.CloseReceiveChannel:
						if (CloseReceiveChannelEvent != null)
						{
							CloseReceiveChannelEvent(this, message);
						}
						break;

					case SccpMessage.Type.ConfigStat:
						if (ConfigStatEvent != null)
						{
							ConfigStatEvent(this, message);
						}
						break;

					case SccpMessage.Type.ConnectionStatisticsReq:
						if (ConnectionStatisticsReqEvent != null)
						{
							ConnectionStatisticsReqEvent(this, message);
						}
						break;

					case SccpMessage.Type.ConnectionStatisticsRes:
						if (ConnectionStatisticsResEvent != null)
						{
							ConnectionStatisticsResEvent(this, message);
						}
						break;

					case SccpMessage.Type.DeactivateCallPlane:
						if (DeactivateCallPlaneEvent != null)
						{
							DeactivateCallPlaneEvent(this, message);
						}
						break;

					case SccpMessage.Type.DefineTimeDate:
						if (DefineTimeDateEvent != null)
						{
							DefineTimeDateEvent(this, message);
						}
						break;

					case SccpMessage.Type.DeviceToUserData:
						if (DeviceToUserDataEvent != null)
						{
							DeviceToUserDataEvent(this, message);
						}
						break;

					case SccpMessage.Type.DeviceToUserDataRes:
						if (DeviceToUserDataResEvent != null)
						{
							DeviceToUserDataResEvent(this, message);
						}
						break;

					case SccpMessage.Type.DialedNumber:
						if (DialedNumberEvent != null)
						{
							DialedNumberEvent(this, message);
						}
						break;

					case SccpMessage.Type.DisplayNotify:
						if (DisplayNotifyEvent != null)
						{
							DisplayNotifyEvent(this, message);
						}
						break;

					case SccpMessage.Type.DisplayPriorityNotify:
						if (DisplayPriorityNotifyEvent != null)
						{
							DisplayPriorityNotifyEvent(this, message);
						}
						break;

					case SccpMessage.Type.DisplayPromptStatus:
						if (DisplayPromptStatusEvent != null)
						{
							DisplayPromptStatusEvent(this, message);
						}
						break;

					case SccpMessage.Type.DisplayText:
						if (DisplayTextEvent != null)
						{
							DisplayTextEvent(this, message);
						}
						break;

					case SccpMessage.Type.FeatureStat:
						if (FeatureStatEvent != null)
						{
							FeatureStatEvent(this, message);
						}
						break;

					case SccpMessage.Type.FeatureStatReq:
						if (FeatureStatReqEvent != null)
						{
							FeatureStatReqEvent(this, message);
						}
						break;

					case SccpMessage.Type.ForwardStat:
						if (ForwardStatEvent != null)
						{
							ForwardStatEvent(this, message);
						}
						break;

					case SccpMessage.Type.HeadsetStatus:
						if (HeadsetStatusEvent != null)
						{
							HeadsetStatusEvent(this, message);
						}
						break;

					case SccpMessage.Type.IpPort:
						if (IpPortEvent != null)
						{
							IpPortEvent(this, message);
						}
						break;

					case SccpMessage.Type.Keepalive:
						if (KeepaliveEvent != null)
						{
							KeepaliveEvent(this, message);
						}
						break;

					case SccpMessage.Type.KeepaliveAck:
						if (KeepaliveAckEvent != null)
						{
							KeepaliveAckEvent(this, message);
						}
						break;

					case SccpMessage.Type.KeypadButton:
						if (KeypadButtonEvent != null)
						{
							KeypadButtonEvent(this, message);
						}
						break;

					case SccpMessage.Type.LineStat:
						if (LineStatEvent != null)
						{
							LineStatEvent(this, message);
						}
						break;

					case SccpMessage.Type.LineStatReq:
						if (LineStatReqEvent != null)
						{
							LineStatReqEvent(this, message);
						}
						break;

					case SccpMessage.Type.OffhookSccp:
						if (OffhookSccpEvent != null)
						{
							OffhookSccpEvent(this, message);
						}
						break;

					case SccpMessage.Type.Onhook:
						if (OnhookEvent != null)
						{
							OnhookEvent(this, message);
						}
						break;

					case SccpMessage.Type.OpenReceiveChannel:
						if (OpenReceiveChannelEvent != null)
						{
							OpenReceiveChannelEvent(this, message);
						}
						break;

					case SccpMessage.Type.OpenReceiveChannelAck:
						if (OpenReceiveChannelAckEvent != null)
						{
							OpenReceiveChannelAckEvent(this, message);
						}
						break;

					case SccpMessage.Type.Register:
						if (RegisterEvent != null)
						{
							RegisterEvent(this, message);
						}
						break;

					case SccpMessage.Type.RegisterAvailableLines:
						if (RegisterAvailableLinesEvent != null)
						{
							RegisterAvailableLinesEvent(this, message);
						}
						break;

					case SccpMessage.Type.RegisterAck:
						if (RegisterAckEvent != null)
						{
							RegisterAckEvent(this, message);
						}
						break;

					case SccpMessage.Type.RegisterReject:
						if (RegisterRejectEvent != null)
						{
							RegisterRejectEvent(this, message);
						}
						break;

					case SccpMessage.Type.RegisterTokenAck:
						if (RegisterTokenAckEvent != null)
						{
							RegisterTokenAckEvent(this, message);
						}
						break;

					case SccpMessage.Type.RegisterTokenReject:
						if (RegisterTokenRejectEvent != null)
						{
							RegisterTokenRejectEvent(this, message);
						}
						break;

					case SccpMessage.Type.RegisterTokenReq:
						if (RegisterTokenReqEvent != null)
						{
							RegisterTokenReqEvent(this, message);
						}
						break;

					case SccpMessage.Type.Reset:
						if (ResetEvent != null)
						{
							ResetEvent(this, message);
						}
						break;

					case SccpMessage.Type.SelectSoftkeys:
						if (SelectSoftkeysEvent != null)
						{
							SelectSoftkeysEvent(this, message);
						}
						break;

					case SccpMessage.Type.ServerRes:
						if (ServerResEvent != null)
						{
							ServerResEvent(this, message);
						}
						break;

					case SccpMessage.Type.ServiceUrlStat:
						if (ServiceUrlStatEvent != null)
						{
							ServiceUrlStatEvent(this, message);
						}
						break;

					case SccpMessage.Type.ServiceUrlStatReq:
						if (ServiceUrlStatReqEvent != null)
						{
							ServiceUrlStatReqEvent(this, message);
						}
						break;

					case SccpMessage.Type.SetLamp:
						if (SetLampEvent != null)
						{
							SetLampEvent(this, message);
						}
						break;

					case SccpMessage.Type.SetRinger:
						if (SetRingerEvent != null)
						{
							SetRingerEvent(this, message);
						}
						break;

					case SccpMessage.Type.SetSpeakerMode:
						if (SetSpeakerModeEvent != null)
						{
							SetSpeakerModeEvent(this, message);
						}
						break;

					case SccpMessage.Type.SetMicroMode:
						if (SetMicroModeEvent != null)
						{
							SetMicroModeEvent(this, message);
						}
						break;

					case SccpMessage.Type.SoftkeyEvent:
						if (SoftkeyEventEvent != null)
						{
							SoftkeyEventEvent(this, message);
						}
						break;

					case SccpMessage.Type.SoftkeySetReq:
						if (SoftkeySetReqEvent != null)
						{
							SoftkeySetReqEvent(this, message);
						}
						break;

					case SccpMessage.Type.SoftkeySetRes:
						if (SoftkeySetResEvent != null)
						{
							SoftkeySetResEvent(this, message);
						}
						break;

					case SccpMessage.Type.SoftkeyTemplateReq:
						if (SoftkeyTemplateReqEvent != null)
						{
							SoftkeyTemplateReqEvent(this, message);
						}
						break;

					case SccpMessage.Type.SoftkeyTemplateRes:
						if (SoftkeyTemplateResEvent != null)
						{
							SoftkeyTemplateResEvent(this, message);
						}
						break;

					case SccpMessage.Type.SpeeddialStat:
						if (SpeeddialStatEvent != null)
						{
							SpeeddialStatEvent(this, message);
						}
						break;

					case SccpMessage.Type.SpeeddialStatReq:
						if (SpeeddialStatReqEvent != null)
						{
							SpeeddialStatReqEvent(this, message);
						}
						break;

					case SccpMessage.Type.StartMediaFailureDetection:
						if (StartMediaFailureDetectionEvent != null)
						{
							StartMediaFailureDetectionEvent(this, message);
						}
						break;

					case SccpMessage.Type.StartMediaTransmission:
						if (StartMediaTransmissionEvent != null)
						{
							StartMediaTransmissionEvent(this, message);
						}
						break;

					case SccpMessage.Type.StartMulticastMediaReception:
						if (StartMulticastMediaReceptionEvent != null)
						{
							StartMulticastMediaReceptionEvent(this, message);
						}
						break;

					case SccpMessage.Type.StartMulticastMediaTransmission:
						if (StartMulticastMediaTransmissionEvent != null)
						{
							StartMulticastMediaTransmissionEvent(this, message);
						}
						break;

					case SccpMessage.Type.StartSessionTransmission:
						if (StartSessionTransmissionEvent != null)
						{
							StartSessionTransmissionEvent(this, message);
						}
						break;

					case SccpMessage.Type.StartTone:
						if (StartToneEvent != null)
						{
							StartToneEvent(this, message);
						}
						break;

					case SccpMessage.Type.StopMediaTransmission:
						if (StopMediaTransmissionEvent != null)
						{
							StopMediaTransmissionEvent(this, message);
						}
						break;

					case SccpMessage.Type.StopMulticastMediaReception:
						if (StopMulticastMediaReceptionEvent != null)
						{
							StopMulticastMediaReceptionEvent(this, message);
						}
						break;

					case SccpMessage.Type.StopMulticastMediaTransmission:
						if (StopMulticastMediaTransmissionEvent != null)
						{
							StopMulticastMediaTransmissionEvent(this, message);
						}
						break;

					case SccpMessage.Type.StopSessionTransmission:
						if (StopSessionTransmissionEvent != null)
						{
							StopSessionTransmissionEvent(this, message);
						}
						break;

					case SccpMessage.Type.StopTone:
						if (StopToneEvent != null)
						{
							StopToneEvent(this, message);
						}
						break;

					case SccpMessage.Type.TimeDateReq:
						if (TimeDateReqEvent != null)
						{
							TimeDateReqEvent(this, message);
						}
						break;

					case SccpMessage.Type.Unregister:
						if (UnregisterEvent != null)
						{
							UnregisterEvent(this, message);
						}
						break;

					case SccpMessage.Type.UnregisterAck:
						if (UnregisterAckEvent != null)
						{
							UnregisterAckEvent(this, message);
						}
						break;

					case SccpMessage.Type.UserToDeviceData:
						if (UserToDeviceDataEvent != null)
						{
							UserToDeviceDataEvent(this, message);
						}
						break;

					case SccpMessage.Type.Version_:
						if (Version_Event != null)
						{
							Version_Event(this, message);
						}
						break;

                    case SccpMessage.Type.UserToDeviceDataVersion1:
                        if(UserToDeviceDataVersion1Event != null)
                        {
                            UserToDeviceDataVersion1Event(this, message);
                        }
                        break;


					default:
						Debug.Fail("SccpStack: invalid message type: {0}",
							message.MessageType.ToString());
						break;
				}
			}
		}

		#region LogVerbose signatures
		/// <summary>
		/// Logs Verbose diagnostic if logVerbose set to true.
		/// </summary>
		/// <param name="message">String to log.</param>
		public void LogVerbose(string text)
		{
			if (isLogVerbose)
			{
				log.Write(TraceLevel.Verbose, text);
			}
		}

		/// <summary>
		/// Logs Verbose diagnostic if logVerbose set to true.
		/// </summary>
		/// <param name="text">String to log.</param>
		/// <param name="args">Variable number of arguments to apply to format
		/// specifiers in text.</param>
		public void LogVerbose(string text, params object[] args)
		{
			if (isLogVerbose)
			{
				log.Write(TraceLevel.Verbose, text, args);
			}
		}
		#endregion

		/// <summary>
		/// Returns a string that represents this object.
		/// </summary>
		/// <returns>String that represents this object.</returns>
		public override string ToString()
		{
			// (Added the try/catches because got null-reference exception
			// once. I guess Local/RemoteEndPoint became null immediately
			// _after_ I tested for it.)

			string local;
			try
			{
				local = LocalEndPoint == null ? "?" : (":" + LocalEndPoint.Port.ToString());
			}
			catch
			{
				local = "?";
			}

			string remote;
			try
			{
				remote = RemoteEndPoint == null ? "?" : RemoteEndPoint.ToString();
			}
			catch
			{
				remote = "?";
			}

			// (Hash code provides a unique identifier for when local and
			// remote are not yet set.)
			return local + "<->" + remote + "(" + this.GetHashCode() + ")";
		}
	}
}
