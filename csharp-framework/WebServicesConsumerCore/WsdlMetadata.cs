using System;
using System.Reflection;
using System.Collections;

namespace Metreos.WebServicesConsumerCore
{
	/// <summary> Parses c# assembly generated by the wsdl-to-code generator </summary>
	public class WsdlMetadata
	{
        public MethodInfo[] Methods { get { return methods; } }
        public Type[] WsdlDefinedTypes { get { return wsdlTypes; } }
        public Hashtable SoapHeaders { get { return soapHeaders; } }

        protected Assembly wsdlAssembly;
        protected MethodInfo[] methods;
        protected Type[] wsdlTypes;
        protected Hashtable soapHeaders;

        protected static Type[] validCommunicationTypes = new Type[]
            {
                typeof(System.Web.Services.Protocols.SoapHttpClientProtocol),
                typeof(System.Web.Services.Protocols.HttpPostClientProtocol),
                typeof(System.Web.Services.Protocols.HttpGetClientProtocol),
                typeof(System.Web.Services.Discovery.DiscoveryClientProtocol) 
            };

        protected static Type[] methodAttributes = new Type[]
            {
                typeof(System.Web.Services.Protocols.SoapDocumentMethodAttribute),
                typeof(System.Web.Services.Protocols.SoapRpcMethodAttribute)
            };

        protected static Type[] dataAttributes = new Type[]
            {
                typeof(System.Xml.Serialization.SoapTypeAttribute),
                typeof(System.Xml.Serialization.XmlTypeAttribute)
            };

        protected static Type[] soapHeaderAttributes = new Type[]
            {
                typeof(System.Web.Services.Protocols.SoapHeaderAttribute)
            };


        public WsdlMetadata(Assembly wsdlAssembly)
		{
			this.wsdlAssembly   = wsdlAssembly;
            this.methods        = null;
            this.wsdlTypes      = null;
            this.soapHeaders = new Hashtable();
		}

        public bool Parse()
        {
            bool parseSuccess = false;
            try
            {
                ParseAssemblyForMethods();
                ParseAssemblyForTypes();
                
                parseSuccess = true;
            }
            catch
            {
                parseSuccess = false;
            }

            return parseSuccess;
        }

        protected void ParseAssemblyForMethods()
        {
            Type[] allTypes = wsdlAssembly.GetTypes();
            Type[] types = FindWsdlClasses(allTypes);
    
            if(types == null)
            {
                return;
            }

            ArrayList list = new ArrayList();

            foreach(Type type in types)
            {
                // Check if this type is a SoapHeader
                PropertyInfo[] sessionHeaderInstances = type.GetProperties();
                
                ParseSoapHeaders(allTypes, sessionHeaderInstances);

                MethodInfo[] methods = type.GetMethods();

                if(methods == null) 
                {
                    continue;
                }

                foreach(MethodInfo method in methods)
                {
                    object[] attributes = method.GetCustomAttributes(false);
                    if(attributes == null || attributes.Length == 0)
                    {
                        continue;
                    }

                    if(FindWsdlMethod(attributes) == true)
                    {
                        list.Add(method);
                    }
                }
            }

            if(list.Count > 0)
            {
                this.methods = new MethodInfo[list.Count];
                list.CopyTo(methods);
            }
        }

        protected void ParseAssemblyForTypes()
        {
            this.wsdlTypes = FindWsdlTypes(wsdlAssembly.GetTypes());
        }

        protected Type[] FindWsdlClasses(Type[] types)
        {
            if(types == null || types.Length == 0) 
            {
                return null;
            }

            ArrayList list = new ArrayList();

            foreach(Type type in types)
            {
                if(true == FindExactType(validCommunicationTypes, type.BaseType))
                {
                    list.Add(type);
                }
            }

            if(list.Count == 0)
            {
                return null;
            }

            Type[] wsdlClassTypes = new Type[list.Count];
            list.CopyTo(wsdlClassTypes);
            return wsdlClassTypes;
        }

        protected Type[] AddEnumerationsNotInXsd(Type[] xsdTypes)
        {
            if(methods == null || methods.Length == 0)
            {
                return new Type[0];
            }

            ArrayList extraTypes = new ArrayList();
            foreach(MethodInfo method in methods)
            {
                if(method.ReturnType.BaseType == typeof(System.Array))
                {
                    // Could be a problem:  an enumeration of an xsd type
                    // is not necessarily listed in the c# xsd section.
                    bool foundMatch = false;

                    foreach(Type type in xsdTypes)
                    {
                        if(type.IsAssignableFrom(method.ReturnType))
                        {
                            // We got a match
                            foundMatch = true;
                            break;
                        }
                    }

                    if(foundMatch == false && 
                       extraTypes.Contains(method.ReturnType) == false &&
                       ContainsSingleElementFromXsd(method.ReturnType, xsdTypes))
                    {
                        // We didn't find the type to deal with this return type
                        extraTypes.Add(method.ReturnType);
                    }
                }
            }

            return (Type[]) extraTypes.ToArray(typeof(Type));
        }

        protected bool ContainsSingleElementFromXsd(Type type, Type[] xsdTypes)
        {
            if(xsdTypes == null || xsdTypes.Length == 0)
            {
                return false;
            }

            foreach(Type xsdType in xsdTypes)
            {
                if(xsdType == type.GetElementType())
                {
                    return true;
                }
            }

            return false;
        }

        protected Type[] FindWsdlTypes(Type[] types)
        {
            if(types == null || types.Length == 0) 
            {
                return null;
            }

            ArrayList list = new ArrayList();

            foreach(Type type in types)
            {
                object[] attributes = type.GetCustomAttributes(false);
                if(attributes == null || attributes.Length == 0)
                {
                    continue;
                }

                if(FindWsdlDataType(attributes) == true)
                {
                    list.Add(type);
                }
            }

            if(list.Count == 0)
            {
                return null;
            }

            list.AddRange(AddEnumerationsNotInXsd((Type[]) list.ToArray(typeof(Type))));

            Type[] wsdlDataTypes = new Type[list.Count];
            list.CopyTo(wsdlDataTypes);
            return wsdlDataTypes;
        }

        protected void ParseSoapHeaders(Type[] allNestedTypes, PropertyInfo[] fields)
        {
            if(allNestedTypes != null)
            {
                foreach(Type type in allNestedTypes)
                {
                    if(IsSoapHeader(type))
                    {
                        AddToSoapHeaders(type, fields);
                    }
                }
            }
        }

        protected bool IsSoapHeader(Type type)
        {
            return type == null ? false : type.BaseType == typeof(System.Web.Services.Protocols.SoapHeader);
        }
       
        protected void AddToSoapHeaders(Type soapHeader, PropertyInfo[] allFields)
        {
            // Find 
            foreach(PropertyInfo field in allFields)
            {
                // Find the field which matches this type.  The name
                // of the field is going to be used as the key in the 
                // soap headers hashtable, because the SoapHeaderAttribute
                // will specify the name of the field instance instead 
                // of the type of the header used

                if(field.PropertyType == soapHeader)
                {
                    this.soapHeaders[field.Name] = soapHeader;
                    // Don't break.  It's probably possible to have 
                    // mulitple headers of the same type, although
                    // I'm not sure. MSC.  At worst this wastes cycles;
                    // no errors can be introduced by this
                }
            }
        }

        protected bool FindExactType(Type[] types, Type type)
        {
            if(types == null || types.Length == 0 || type == null)
            {
                return false;
            }

            foreach(Type typeToCheck in types)
            {
                if(typeToCheck == type)
                {
                    return true;
                }
            }

            return false;
        }

        protected bool FindWsdlDataType(Array array)
        {
            if(array == null || array.Length == 0)
            {
                return false;
            }

            foreach(object obj in array)
            {
                foreach(Type type in dataAttributes)
                {
                    if(obj.GetType() == type)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        protected bool FindWsdlMethod(Array array)
        {
            if(array == null || array.Length == 0)
            {
                return false;
            }

            foreach(object obj in array)
            {
                foreach(Type type in methodAttributes)
                {
                    if(obj.GetType() == type)
                    {
                        return true;
                    }
                }
            }

            return false;
        }
	}
}
